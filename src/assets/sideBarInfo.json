{
    
    "/" : {
        "text" : "<section><h1>Stack Data Structure</h1><p>A stack is a fundamental data structure that follows the Last In, First Out (LIFO) principle, resembling a stack of plates or books. It's a collection of elements with two primary operations: push and pop. Let's delve into the mechanics of how a stack works.</p></section><section><h2>Structure</h2><p>A stack is typically implemented using an array or a linked list. Each element in the stack is referred to as a \"node.\" The top of the stack is the last element added, and the bottom is the first element added. The stack has a fixed capacity in the case of an array-based implementation, while a linked list-based implementation can dynamically adjust to the required size.</p></section><section><h2>Operations</h2><h3>Push</h3><ul><li>The push operation adds an element to the top of the stack.</li><li>It increments the stack pointer (or top pointer) to the next position and stores the new element in that location.</li></ul><h3>Pop</h3><ul><li>The pop operation removes the element from the top of the stack.</li><li>It retrieves the element at the current stack pointer, decrements the stack pointer, and returns the element.<a href='https://m13ha.hashnode.dev/data-structures-stacks-and-queues-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/n5zsdqch/4/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    },
    "/stacks" : {
        "text" : "<section><h1>Stack Data Structure</h1><p>A stack is a fundamental data structure that follows the Last In, First Out (LIFO) principle, resembling a stack of plates or books. It's a collection of elements with two primary operations: push and pop. Let's delve into the mechanics of how a stack works.</p></section><section><h2>Structure</h2><p>A stack is typically implemented using an array or a linked list. Each element in the stack is referred to as a \"node.\" The top of the stack is the last element added, and the bottom is the first element added. The stack has a fixed capacity in the case of an array-based implementation, while a linked list-based implementation can dynamically adjust to the required size.</p></section><section><h2>Operations</h2><h3>Push</h3><ul><li>The push operation adds an element to the top of the stack.</li><li>It increments the stack pointer (or top pointer) to the next position and stores the new element in that location.</li></ul><h3>Pop</h3><ul><li>The pop operation removes the element from the top of the stack.</li><li>It retrieves the element at the current stack pointer, decrements the stack pointer, and returns the element.<a href='https://m13ha.hashnode.dev/data-structures-stacks-and-queues-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/n5zsdqch/4/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    },
    "/queues" : {
        "text" : "<section><h1>Queue Data Structure</h1><p>A queue is a fundamental data structure that follows the First In, First Out (FIFO) principle, similar to a line of people waiting. It's a collection of elements with two primary operations: enqueue and dequeue. Let's explore how a queue functions.</p></section><section><h2>Structure</h2><p>A queue is typically implemented using an array or a linked list. Each element in the queue is referred to as a \"node.\" The front of the queue is where elements are dequeued, and the rear is where elements are enqueued. Unlike a stack, a queue does not have a fixed capacity.</p></section><section><h2>Operations</h2><h3>Enqueue</h3><ul><li>The enqueue operation adds an element to the rear of the queue.</li><li>It increments the rear pointer to the next position and stores the new element in that location.</li></ul><h3>Dequeue</h3><ul><li>The dequeue operation removes the element from the front of the queue.</li><li>It retrieves the element at the current front position, increments the front pointer, and returns the element. <a href='https://m13ha.hashnode.dev/data-structures-stacks-and-queues-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/mv7o8yfc/1/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    },
    "/lists" : {
        "text" : "<section><h1>Linked List Data Structure</h1><p>A linked list is a linear data structure consisting of nodes, where each node points to the next node in the sequence. Unlike arrays, linked lists do not have a fixed size and can dynamically adjust. Let's explore the mechanics of how a linked list works.</p></section><section><h2>Structure</h2><p>In a singly linked list, each node contains data and a reference (or link) to the next node in the sequence. The last node points to null, indicating the end of the list. In a doubly linked list, each node has references to both the next and previous nodes, allowing traversal in both directions.</p></section><section><h2>Operations</h2><h3>Insertion</h3><ul><li>Insertion adds a new node to the linked list at a specified position.</li><li>The new node's link is adjusted to point to the next node, and the previous node is updated to point to the new node.</li></ul><h3>Deletion</h3><ul><li>Deletion removes a node from the linked list.</li><li>The links of the previous and next nodes are adjusted to bypass the deleted node, effectively removing it from the sequence.</li></ul><h3>Traversal</h3><ul><li>Traversal involves visiting each node in the linked list, starting from the head (the first node).</li><li>It's done by following the links from one node to the next until the end of the list is reached. <a href='https://m13ha.hashnode.dev/data-structures-linked-list-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/wesb89m0/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    },
    "/trees" : {
        "text" : "<section><h1>Tree Data Structure</h1><p>A tree is a hierarchical data structure composed of nodes, where each node has a value and zero or more child nodes. The topmost node is called the root, and nodes with no children are called leaves. Let's explore the fundamentals of how a tree works.</p></section><section><h2>Structure</h2><p>A tree consists of nodes connected by edges. Each node, except the root, has a parent, and each node can have zero or more children. Nodes with the same parent are called siblings. The depth of a node is the length of the path from the root to that node, and the height of the tree is the length of the longest path from the root to a leaf.</p></section><section><h2>Types of Trees</h2><p>There are various types of trees, including:</p><ul><li><strong>Binary Tree:</strong> Each node has at most two children, typically referred to as the left child and the right child.</li><li><strong>Binary Search Tree (BST):</strong> A binary tree with the additional property that the left child of a node contains values less than the node, and the right child contains values greater than the node.</li></ul></section><section><h2>Operations</h2><p>Common operations on trees include:</p><ul><li><strong>Traversal:</strong> Visiting each node in a specific order, such as in-order, pre-order, or post-order.</li><li><strong>Insertion:</strong> Adding a new node to the tree while maintaining the hierarchical structure.</li><li><strong>Deletion:</strong> Removing a node from the tree, preserving the tree properties.</li><li><strong>Search:</strong> Finding a specific node or value in the tree. <a href='https://m13ha.hashnode.dev/data-structures-trees-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/qb7tjgya/1/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    },
    "/graphs" : {
        "text" : "<section><h1>Graph Data Structure</h1><p>A graph is a collection of nodes (vertices) and edges that connect pairs of nodes. Graphs are versatile data structures used to represent relationships between entities. Let's explore the essential concepts of how a graph works.</p></section><section><h2>Types of Graphs:</h2><p>Graphs can be categorized into various types, including:</p><ul><li><strong>Directed Graph (Digraph):</strong> Edges have a direction, indicating a one-way connection between nodes.</li><li><strong>Undirected Graph:</strong> Edges have no direction, representing a symmetric relationship between nodes.</li><li><strong>Weighted Graph:</strong> Edges have weights or costs associated with them.</li><li><strong>Unweighted Graph:</strong> All edges have the same weight or cost.</li></ul></section><section><h2>Structure:</h2><p>A graph is defined by its nodes and edges. Nodes can represent entities, and edges represent relationships between those entities. The collection of nodes and edges is often referred to as the \"graph structure.\"</p></section><section><h2>Operations</h2><p>Common operations and algorithms on graphs include:</p><ul><li><strong>Traversal:</strong> Visiting each node in the graph, typically using depth-first search (DFS) or breadth-first search (BFS).</li><li><strong>Path Finding:</strong> Finding the shortest path between two nodes, often using algorithms like Dijkstra's algorithm or A*.</li><li><strong>Minimum Spanning Tree:</strong> Finding a subgraph that connects all nodes with the minimum possible total edge weight. <a href='https://m13ha.hashnode.dev/data-structures-graphs-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/5vL4esrj/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    },
    "/hashtables" : {
        "text" : "<section><h1>Hash Table Data Structure</h1><p>A hash table (hash map) is a data structure that implements an associative array abstract data type. It uses a hash function to compute an index into an array of buckets, from which the desired value can be found. Let's explore the key concepts of how a hash table works.</p></section><section><h2>Structure:</h2><p>A hash table typically consists of an array of buckets, each associated with a unique index. Each bucket can store key-value pairs. The hash function takes a key as input and produces an index, mapping the key to the corresponding bucket. In case of hash collisions (different keys hashing to the same index), various collision resolution techniques are employed, such as chaining or open addressing.</p></section><section><h2>Operations:</h2><p>Common operations on hash tables include:</p><ul><li><strong>Insertion:</strong> Adding a key-value pair to the hash table.</li><li><strong>Deletion:</strong> Removing a key-value pair from the hash table.</li><li><strong>Lookup:</strong> Retrieving the value associated with a specific key.</li><li><strong>Collision Resolution:</strong> Handling situations where multiple keys hash to the same index. <a href='https://m13ha.hashnode.dev/data-structures-hash-tables-i' target='_'>Learn More</a></li></ul></section>",
        "code" : "<iframe width='100%' height='95%' src='//jsfiddle.net/m13ha/ceLzudo7/1/embedded/js/dark/' allowfullscreen='allowfullscreen' allowpaymentrequest frameborder='0'></iframe>"

    }

}